#!/bin/sh
set -euo pipefail

SCRIPT_DIR=$(cd $(dirname $0); pwd)
HANDLER_NAME=$(echo "$_HANDLER" | cut -d. -f2)
HANDLER_FILE=$(echo "$_HANDLER" | cut -d. -f1)

API_ROOT=http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/

# If we fail prior to the handler loop we post an init error.
function error {
  echo "error:" $1
  ERROR="{\"errorMessage\" : \"$1\", \"errorType\" : \"InitException\"}"
  # FIXME show a more descriptive message (not output {"status":"OK"})
  curl -s -X POST "${API_ROOT}init/error" \
       -d "$ERROR" \
       --header "Lambda-Runtime-Function-Error-Type: Unhandled" \
       --output /tmp/init.out
  # expect it to be {"status":"OK"}
  grep -q OK /tmp/init.out \
   || (echo "Unexpected bootstrap error when calling AWS_LAMBDA_RUNTIME_API /init/error:" \
       && cat /tmp/init.out)
  exit 1
}

# If the script fails we try and determine why.
function investigate {
  [ -f $SCRIPT_DIR/amz-deno ] \
   || error "missing amz-deno executable"

  $SCRIPT_DIR/amz-deno eval 'Deno.version.deno' \
   || error "bad amz-deno executable"

  [ -f $LAMBDA_TASK_ROOT/$HANDLER_FILE.ts ] \
   || error "missing expected handler file '$HANDLER_FILE.ts'"

  DENO_DIR=/tmp/deno_dir NO_COLOR=true $SCRIPT_DIR/amz-deno fetch $LAMBDA_TASK_ROOT/$HANDLER_FILE.ts \
   || error "unable to compile $HANDLER_FILE.ts"

  echo "
  import { $HANDLER_NAME } from '$LAMBDA_TASK_ROOT/$HANDLER_FILE.ts';
  " > /tmp/runtime-test.js
  DENO_DIR=/tmp/deno_dir NO_COLOR=true $SCRIPT_DIR/amz-deno fetch /tmp/runtime-test.js 2> /dev/null \
   || error "$HANDLER_FILE.ts must export a function named '$HANDLER_NAME'"

  # perhaps a bug in bootstrap?
}

# Note: This is a js file to avoid a runtime compilation step.
# Hopefully $HANDLER_FILE.ts's compilation is cached in DENO_DIR.
echo "
import { $HANDLER_NAME } from '$LAMBDA_TASK_ROOT/$HANDLER_FILE.ts';
const INVOCATION = '${API_ROOT}invocation/';
while (true) {
  const next = await fetch(INVOCATION + 'next');
  const reqId = next.headers.get('Lambda-Runtime-Aws-Request-Id');
  let res;
  try {
    const body = await $HANDLER_NAME(await next.json());
    res = await fetch(INVOCATION + reqId + '/response', {
      method: 'POST',
      body: JSON.stringify(body)
    });
  } catch(e) {
    console.error(e);
    // If it's an Error we can pull these out cleanly...
    // BUT it's javascript so it could be anything!
    let { name, message } = e;
    if (name === undefined) {
      name = 'Error';
    }
    if (typeof(name) !== 'string') {
      name = JSON.stringify(name)
    }
    if (message === undefined) {
      message = e;
    }
    if (typeof(message) !== 'string') {
      message = JSON.stringify(message)
    }
    res = await fetch(INVOCATION + reqId + '/error', {
      method: 'POST',
      body: JSON.stringify({
        errorMessage: message,
        errorType: name
      })
    });
  }
  await res.blob();
}
" > /tmp/runtime.js

# This assumes that .deno_dir was included in the zip.
# The idea is to workaround full, rather than relative, file paths.
# See README.md.

mkdir -p /tmp/deno_dir/gen/file$LAMBDA_TASK_ROOT \
 && cp -R $LAMBDA_TASK_ROOT/.deno_dir/LAMBDA_TASK_ROOT/ /tmp/deno_dir/gen/file$LAMBDA_TASK_ROOT \
 || echo "warn: Unable to import DENO_DIR from .deno_dir"

DENO_DIR=/tmp/deno_dir NO_COLOR=true $SCRIPT_DIR/amz-deno run --allow-net --allow-read /tmp/runtime.js \
 || investigate
